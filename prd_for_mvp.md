# Rootie - MVP 产品需求文档

- **文档版本**: 0.1
- **产品名称**: Rootie
- **创建日期**: 2025-06-26
- **产品负责人**: Sean
- **目标阶段**: MVP (Minimum Viable Product)

---

## 1. 产品概述 (Overview)

### 1.1 产品愿景 (Vision)
本产品旨在颠覆传统的线性AI对话模式，通过引入可分支的树状对话结构和无限画布的交互界面，打造一个更利于知识学习、深度思考和信息探索的图谱化人机交互范式。

### 1.2 问题陈述 (Problem Statement)
传统的“一问一答”式聊天机器人交互流是线性的，当用户希望就某一历史信息点进行深入探讨或比较不同思路时，往往会打乱主对话流，导致上下文混乱，不利于复杂问题的梳理和知识体系的构建。

### 1.3 目标用户 (Target Audience)
- **学生与研究人员**: 需要整理思路、进行文献研究和构建知识框架的用户。
- **创作者与分析师**: 需要进行头脑风暴、探索不同创意路径和方案的用户。
- **终身学习者**: 对复杂概念有深度学习和探索欲望的个人。

### 1.4 核心价值 (Core Value)
- **结构化思考**: 将对话内容以节点和连线的形式可视化，帮助用户理清思路。
- **无扰式探索**: 支持从任意对话节点开启子话题，而不干扰主对话链路。
- **上下文继承**: 保证对话分支能继承其上游节点的完整语境，实现有深度的连续对话。

---

## 2. 功能需求 (Functional Requirements)

### 2.1 用户故事 (User Stories)

**史诗故事1: 核心对话与图谱构建**

- **User Story 1.1**: 作为一个新用户，我希望能在一个空白画布的起始节点上输入第一个问题，并得到AI的回答，形成第一个对话节点，以便开始我的探索之旅。
- **User Story 1.2**: 作为一个用户，当AI回答后，我可以从我的问题节点或AI的回答节点上再次发起提问，新生成的问答对将作为一个新的子节点连接到我发起提问的节点上，形成一条对话链路。
- **User Story 1.3**: 作为一个用户，我想在一个已存在的节点上开启一个全新的、不同方向的对话，系统应能从该节点创建出一个新的分支，而不是简单地延续旧的链路。
- **User Story 1.4**: 作为一个用户，我希望AI在回答我在分支节点上的问题时，能够理解从根节点到当前分支节点的全部对话历史，以提供具有上下文连续性的回答。

**史诗故事2: 画布交互**

- **User Story 2.1**: 作为一个用户，我可以在无限大的画布上自由拖动和摆放我的对话节点，以便按我喜欢的方式组织我的知识图谱。
- **User Story 2.2**: 作为一个用户，我可以使用鼠标滚轮或触控板手势对画布进行缩放，以便在宏观上查看整个对话图谱的结构，或在微观上聚焦于某个具体节点的细节。
- **User Story 2.3**: 作为一个用户，我可以按住画布的空白区域并拖动，以平移我的视口，方便地浏览图谱的不同区域。


### 2.2 功能详述 (Feature Details)

#### 2.2.1 AI问答服务 (Core Q&A Service)
- **描述**: 系统后端的核心服务，负责接收前端的用户输入和上下文，调用第三方AI模型API，并将结果返回。
- **需求**:
    - **输入**:
        - `prompt`: 用户的当前提问 (string)。
        - `parent_node_id`: 用户发起提问所基于的节点ID (string/integer)。若为初次提问，则此项为空。
    - **处理**:
        - 后端根据 `parent_node_id` 在数据库中回溯，构建从根节点到父节点的完整对话历史（上下文）。
        - 将构建好的上下文和当前 `prompt` 组合成一个完整的请求。
        - 调用至少一个预设的第三方模型供应商API（例如火山引擎 API）。
        - **MVP阶段**: 暂时不提供用户切换模型的功能，使用系统默认模型。
    - **输出**:
        - `new_node_data`: 包含新生成的用户问题和AI回答内容，以及其节点ID和父节点ID。
- **验收标准**:
    - 用户在前端发起提问后，能在画布上看到一个包含AI回答的新节点被创建并连接到父节点。
    - AI的回答与其对话链上的历史上下文相关。

#### 2.2.2 无限画布与节点交互 (Infinite Canvas & Node Interaction)
- **描述**: 产品的主交互界面，一个可无限缩放和平移的2D空间。
- **需求**:
    - **画布**:
        - 支持鼠标滚轮/手势缩放。
        - 支持鼠标拖拽平移。
        - 性能：在节点数少于100个时，操作应保持流畅。
    - **节点 (Node)**:
        - 每个节点代表一次QA（用户提问+AI回答）。
        - 节点应清晰地展示问题和答案。
        - 节点之间用有向箭头（或连线）表示对话的先后顺序和分支关系。
        - 点击节点会高亮，并显示“从此发起新对话”的按钮/交互提示。
    - **链路 (Link)**:
        - 自动在父节点和子节点之间绘制连接线。
- **验收标准**:
    - 用户可以流畅地对画布进行缩放和平移。
    - 用户可以通过点击节点上的按钮来创建新的对话分支。
    - 对话链路清晰地展示了对话的流转和分支结构。

#### 2.2.3 上下文管理 (Context Management)
- **描述**: 后端的核心逻辑，确保AI对话的连贯性。
- **需求**:
    - 当从节点N发起新对话时，系统必须将从“根节点 -> ... -> N的父节点 -> N”这条路径上的所有QA内容组合成上下文。
- **验收标准**:
    - 在一个深度为5的对话链的分支上提问，AI的回答应能体现出对前4层对话内容的理解。

---

## 3. 技术栈与数据结构 (Tech Stack & Data Structure)

### 3.1 技术栈 (Tech Stack)
- **前端**: React
- **后端**: Python, FastAPI
- **数据库**: PostgreSQL (推荐, 因其对复杂查询和数据完整性的良好支持)
- **关键库**:
    - 前端: `React Flow` (推荐用于画布实现), `axios` (用于API请求)
    - 后端: `httpx` (用于异步调用外部API), `SQLAlchemy` (用于ORM)、`pydantic-settings` (用于管理配置)

### 3.2 数据模型 (Data Model)
- **核心数据表**: `dialogue_nodes`
- **字段建议**:
    - `id`: 主键, 唯一标识 (e.g., UUID)
    - `user_id`: 外键, 关联用户表
    - `graph_id`: 标识属于哪个对话图谱
    - `parent_node_id`: 外键, 自我关联, 指向父节点ID (根节点的此字段为NULL)
    - `user_prompt`: 用户输入的问题 (TEXT)
    - `ai_response`: AI生成的回答 (TEXT)
    - `created_at`: 创建时间戳
    - `position_x`: 节点在画布上的x坐标 (FLOAT, 可选, 也可纯前端管理)
    - `position_y`: 节点在画布上的y坐标 (FLOAT, 可选)

### 3.3 配置与密钥管理 (Configuration & Secrets Management) 
- **原则**: **严禁**将任何敏感信息（如API密钥、数据库密码、JWT密钥等）硬编码到源代码中。所有配置项应通过环境变量进行管理。 
- **实现方式**: 
- 后端应用 (FastAPI) 启动时，应从运行环境中加载环境变量。推荐使用 `pydantic-settings` 库来解析和验证配置。 
- 项目仓库中应包含一个环境文件模板，例如 `.env.example`，用于告知开发者需要设置哪些环境变量，但不包含任何真实的值。 
- 开发者在本地开发时，应创建自己的 `.env` 文件（此文件应被添加到 `.gitignore` 中，防止被提交到版本库）。 
- 在生产环境部署时，应通过部署平台（如Docker, Heroku, Vercel）提供的机制来设置环境变量。
 - **环境变量示例 (`.env.example`)**:
 ```ini
 # 应用配置
ENVIRONMENT="development" # "development" or "production" 
SECRET_KEY="<your-strong-random-secret-key-for-jwt>" 
# 数据库配置 
DATABASE_URL="postgresql://user:password@host:port/dbname" 
# 第三方服务API密钥 
# MVP阶段至少需要一个 
OPENAI_API_KEY="<your-openai-api-key>" 
# ANTHROPIC_API_KEY="<your-anthropic-api-key>" # 预留 
# GOOGLE_API_KEY="<your-google-api-key>" # 预留
```
---

## 4. 非功能性需求 (Non-Functional Requirements)

- **性能 (Performance)**:
    - 页面初始加载时间 < 3秒。
    - AI响应时间主要取决于第三方API，但后端处理时间应 < 500ms。
- **可用性 (Usability)**:
    - 界面简洁直观，新用户无需教程即可完成核心操作。
    - 画布交互（拖拽、缩放）必须流畅无卡顿。
- **可扩展性 (Scalability)**:
    - 后端架构应设计成可以方便地增加新的AI模型供应商或插件。

---

## 5. MVP范围 (MVP Scope)

### 5.1 包含功能 (In-Scope for MVP)
- [x] 创建、保存、加载对话图谱。
- [x] 在无限画布上进行核心对话。
- [x] 从任意节点创建对话分支。
- [x] 完整的上下文继承。
- [x] 画布的平移和缩放。
- [x] 后端集成至少1个主流AI模型供应商。

### 5.2 暂不包含功能 (Out-of-Scope for MVP)
- [ ] 多用户实时协作编辑同一个图谱。
- [ ] 用户自定义选择不同的AI模型。
- [ ] 第三方插件（如联网搜索、代码执行）的集成。
- [ ] 节点的富文本编辑（如插入图片、链接）。
- [ ] 移动端原生应用或响应式设计优化。
- [ ] 复杂的节点样式自定义。
- [ ] 导出图谱为图片或PDF。
- [ ] 用户注册与登录。

